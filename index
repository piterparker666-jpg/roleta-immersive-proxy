'use strict';

const http = require('http');
const { URL } = require('url');

const PORT = Number(process.env.PORT || 10000);

// Env vars (Render)
const UPSTREAM = (process.env.UPSTREAM || '').trim();          // URL completa do JSON
const BASIC_USER = (process.env.BASIC_USER || '').trim();
const BASIC_PASS = (process.env.BASIC_PASS || '').trim();
const ALLOW_ORIGIN = (process.env.ALLOW_ORIGIN || '*').trim();

function json(res, code, obj, extraHeaders = {}) {
  const body = JSON.stringify(obj, null, 2);
  res.writeHead(code, {
    'Content-Type': 'application/json; charset=utf-8',
    'Cache-Control': 'no-store',
    'Access-Control-Allow-Origin': ALLOW_ORIGIN,
    'Access-Control-Allow-Methods': 'GET,OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    ...extraHeaders,
  });
  res.end(body);
}

function okPayloadFromRaw(raw, httpCode) {
  // Aceita: array direto OU {items:[...]} OU qualquer JSON que seja array
  let items = [];
  if (Array.isArray(raw)) items = raw;
  else if (raw && Array.isArray(raw.items)) items = raw.items;

  // normaliza pra números 0..36
  items = (items || [])
    .map(n => Number(n))
    .filter(n => Number.isFinite(n) && n >= 0 && n <= 36);

  return {
    ok: httpCode >= 200 && httpCode < 300 && items.length > 0,
    items,
    status: (raw && Number.isFinite(raw.status)) ? raw.status : httpCode,
    hint: (raw && typeof raw.hint === 'string') ? raw.hint : '',
    ts: (raw && Number.isFinite(raw.ts)) ? raw.ts : Date.now(),
    source: 'render-proxy',
  };
}

async function fetchUpstream() {
  if (!UPSTREAM) {
    return { code: 500, text: '', err: 'UPSTREAM vazio (env var não definida).' };
  }

  const headers = {
    'Accept': 'application/json,text/plain,*/*',
  };

  // Basic Auth (se user/pass existirem)
  if (BASIC_USER || BASIC_PASS) {
    const token = Buffer.from(`${BASIC_USER}:${BASIC_PASS}`).toString('base64');
    headers['Authorization'] = `Basic ${token}`;
  }

  // Bypass cache opcional: adiciona ?t=timestamp
  const u = new URL(UPSTREAM);
  u.searchParams.set('t', String(Date.now()));

  const r = await fetch(u.toString(), { method: 'GET', headers });
  const code = r.status;
  const text = await r.text();
  return { code, text, err: null };
}

const server = http.createServer(async (req, res) => {
  try {
    // CORS preflight
    if (req.method === 'OPTIONS') {
      res.writeHead(204, {
        'Access-Control-Allow-Origin': ALLOW_ORIGIN,
        'Access-Control-Allow-Methods': 'GET,OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Max-Age': '86400',
      });
      return res.end();
    }

    const url = new URL(req.url, `http://${req.headers.host || 'localhost'}`);
    const path = url.pathname;

    // Health
    if (path === '/health') {
      return json(res, 200, { ok: true, service: 'roleta-immersive-proxy', ts: Date.now() });
    }

    // Endpoint principal
    if (req.method !== 'GET') {
      return json(res, 405, { ok: false, error: 'Método não permitido' });
    }

    const { code, text, err } = await fetchUpstream();
    if (err) return json(res, 500, { ok: false, error: err });

    let raw = null;
    try {
      raw = JSON.parse(text);
    } catch (_) {
      // Se vier texto não-JSON, devolve debug curto
      return json(res, 502, {
        ok: false,
        error: 'Upstream não retornou JSON válido',
        status: code,
        sample: String(text || '').slice(0, 180),
      });
    }

    const out = okPayloadFromRaw(raw, code);

    // Debug leve (pra tu enxergar se tá puxando a mesa certa)
    out.debug = {
      httpCode: code,
      upstreamHost: (() => {
        try { return new URL(UPSTREAM).host; } catch { return ''; }
      })(),
    };

    return json(res, out.ok ? 200 : 502, out);
  } catch (e) {
    return json(res, 500, { ok: false, error: String(e && e.message ? e.message : e) });
  }
});

server.listen(PORT, () => {
  console.log(`[ok] listening on :${PORT}`);
  console.log(`[ok] upstream = ${UPSTREAM || '(empty)'}`);
});
